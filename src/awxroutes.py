#!/bin/env python3
from flask import Flask,request,render_template,jsonify,redirect, url_for,abort,make_response
import json
from runapi import *
from app import app
from accessops import *
from dbops import *
from sharedfunctions import *
#from login import *
import os
import re

try:
  DOMAIN=os.environ["DOMAIN"]
except:
  DOMAIN="domain.company.com"

try:
  LOCALDEV=os.environ["LOCALDEV"]
except:
  LOCALDEV="no"

try: 
  URLPREFACE=os.environ["URLPREFACE"]
except:
  URLPREFACE=""

cookiesecurity=True
if LOCALDEV=="yes":
  cookiesecurity=False

# This function hides stdout/stderr data that is known to be less than useful for a human to see from every job's log
def removeTypicalAWXGarbage(tosay):
  # this is generated by the Beyond Trust plugin
  tosay=tosay.replace("""
https://company.com/BeyondTrust/api/public/v3
/usr/local/lib/python3.9/site-packages/urllib3/connectionpool.py:1045: InsecureRequestWarning: Unverified HTTPS request is being made to host &#x27;iambyti1p002.company.com&#x27;. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html#ssl-warnings
  warnings.warn(
""","<br>")
  return tosay

# example http://localhost:5000/runjobawxreq?awx-job-name=automation-awx-jobtesting-job&extravarfavoritecolor=aaa&extravarfavoriteanimal=bbbb
@app.route('/runjobawxreq', methods=["GET"])
def post_url_to_awx():
  print(f"Request to runjob is: {request.args}")
  if not request.args:
    e="No arguments sent to URL."
    errorcode=400
    return render_template('error.html',data=e,errorcode=errorcode,URLPREFACE=URLPREFACE)
  sessionid=request.cookies.get('sessionid')
  sessioncheckresults=checkUserSession(sessionid)
  assjobparams=""
  print(f"request.args is {request.args.to_dict()}")
  for item in request.args.to_dict():
    assjobparams=assjobparams+item+"="+request.args[item]+"&"
  if sessioncheckresults!="ok":
    return render_template('login.html', redirecturl=f"{URLPREFACE}/runjobawxreq?{assjobparams}",URLPREFACE=URLPREFACE,userinfo=f"Please log in with your ABC Active Directory account to continue to runjobawxreq?{assjobparams}.")
  try:
    jobname=request.args['awx-job-name']
  except Exception as e:
    return render_template('errorrunningjob.html',jobdata=f"There was an error launching the job. Mandatory parameter awx-job-name not specified")
  # check if this job is allowed to be ran via url (this is governed by the json file's run-via list)
  if jobname not in getJobsRanByURL():
    e=f"This job is not allowed to be ran via this method. {jobname} not in {getJobsRanByURL()}"
    errorcode=403
    return render_template('error.html',data=e,errorcode=errorcode,URLPREFACE=URLPREFACE)
  username=retrieveDBData(sessionid,"username")
  canrun=checkUserJobPerms(sessionid,username,jobname)
  if canrun==False:
    e="You are not in a group that is allowed to run this job"
    errorcode=403
    return render_template('error.html',data=e,errorcode=errorcode,URLPREFACE=URLPREFACE)
  print(f"Attempting to run via api {username} is username and request form is {request.form} ")
  jobID=runAPIJob(request.args,username,{})
  if "results" in jobID:
    jobida=json.loads(jobID)
    print("attempting redirect")
    return redirect(f"{URLPREFACE}"+url_for('follow_on_awx', jobid=jobida["results"]))
  else:
    print("attempting render template")
    return render_template('errorrunningjob.html',jobdata=f"There was an error launching the job. Received this reply when trying to launch: {jobID}",URLPREFACE=URLPREFACE)


# Run a job via a post from the human-interactive form
@app.route('/runjobawx', methods=["POST"])
def post_to_awx():
  print(f"Request to runjob is: {request.form}")
  sessionid=request.cookies.get('sessionid')
  sessioncheckresults=checkUserSession(sessionid)
  username=retrieveDBData(sessionid,"username")
  if sessioncheckresults!="ok":
    return render_template('login.html', redirecturl=f"{URLPREFACE}/",userinfo=f"Please log in with your ABC Active Directory account.")
  # give error if nothing sent via post
  if not request.form:
    e="No arguments were sent via post."
    errorcode=400
    return render_template('error.html',data=e,errorcode=errorcode,URLPREFACE=URLPREFACE)
  jobname=request.form['awx-job-name']
  print(f"{sessionid} {username} is trying to run {jobname}...")
  # check if user can run this job
  canrun=checkUserJobPerms(sessionid,username,jobname)
  if canrun == False:
    e="You are not in a group that is allowed to run this job"
    errorcode=403
    return render_template('error.html',data=e,errorcode=errorcode,URLPREFACE=URLPREFACE)
  jobID=runAPIJob(request.form,username,{})
  if "results" in jobID:
    jobida=json.loads(jobID)
    print(f"DEBUG: url_for is "+url_for('follow_on_awx'))
    # consider eliminating urlpreface on this
    return redirect(f"{URLPREFACE}"+url_for('follow_on_awx', jobid=jobida["results"]))
  else:
    return render_template('errorrunningjob.html',jobdata=f"There was an error launching the job. Received this reply when trying to launch: {jobID}",URLPREFACE=URLPREFACE)

# This is a text-only version of the job's output to facilitate the end user viewing the log and not overwhelming with requests
@app.route('/awxjobabridged', methods=["GET"])
def follow_on_awx_ajax():
  sessionid=request.cookies.get('sessionid')
  sessioncheckresults=checkUserSession(sessionid)
  if not request.args:
    return {"error": "No params were sent to this url."}
  jobid=request.args["jobid"]
  
  if sessioncheckresults!="ok":
    return {"error":"session is invalid."}
  try:
    jobname=getJobName(request.args["jobid"])
  except Exception as e:
    return {"error": "There was an error launching the job. Received this reply when trying to launch: {e}"}
  username=retrieveDBData(sessionid,"username")

  canrun=checkUserJobPerms(sessionid,username,jobname)
  if canrun == False:
    e="You are not in a group that is allowed to run this job"
    errorcode=403
    return render_template('error.html',data=e,errorcode=errorcode,URLPREFACE=URLPREFACE)
  jobData=getOutputAPI(request.args["jobid"],"html")
  jobData=json.loads(jobData)
  logfilter=getJobLogFilters(jobname)
  jobresults=jobData["results"]
  jobresults=removeTypicalAWXGarbage(jobresults)
  # per-job specific filtering
  if logfilter!={}:
    if "replacements" in logfilter:
      for replacement in logfilter["replacements"]:
        jobresults=jobresults.replace(replacement['to_replace'],replacement['replacement'])
    if "regex_replacements" in logfilter:
      for replacement in logfilter["regex_replacements"]:
        jobresults=re.sub(replacement['to_replace'],replacement['replacement'], jobresults)
  tosay=jobresults
  return tosay

# This is the human-friendly log output page called after a job is executed
@app.route('/awxviewjob', methods=["GET"])
def follow_on_awx():
  if not request.args:
    e="No parameters were sent in your request."
    errorcode=400
    return render_template('error.html',data=e,URLPREFACE=URLPREFACE,errorcode=errorcode)
  sessionid=request.cookies.get('sessionid')
  sessioncheckresults=checkUserSession(sessionid)
  try:
    jobname=getJobName(request.args["jobid"])
  except Exception as e:
    return render_template('errorrunningjob.html',URLPREFACE=URLPREFACE, jobdata=f"There was an error launching the job. Received this reply when trying to launch: {e}")
  jobid=request.args["jobid"]
  if sessioncheckresults!="ok": 
    return render_template('login.html', URLPREFACE=URLPREFACE, redirecturl=f"{URLPREFACE}/awxviewjob?jobid={jobid}",userinfo=f"Please log in with your ABC Active Directory account to continue to /awxviewjob?jobid={jobid}.")
  username=retrieveDBData(sessionid,"username")
  canrun=checkUserJobPerms(sessionid,username,jobname)
  if canrun == False:
    e="You are not in a group that is allowed to run this job"
    errorcode=403
    return render_template('error.html',data=e,errorcode=errorcode,URLPREFACE=URLPREFACE)
  expiry=renewDBSession(sessionid)
  resp=make_response(render_template('viewrunjob.html',jobid=jobid,URLPREFACE=URLPREFACE))
  resp.set_cookie('sessionid', sessionid, httponly=True, secure=cookiesecurity, samesite='Lax',expires=expiry)
  return resp

